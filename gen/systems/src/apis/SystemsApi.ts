/* tslint:disable */
/* eslint-disable */
/**
 * Tapis Systems API
 * The Tapis Systems API provides for management of Tapis Systems including permissions, credentials and Scheduler Profiles.
 *
 * The version of the OpenAPI document: 1.7.0
 * Contact: cicsupport@tacc.utexas.edu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ListTypeEnum,
    ListTypeEnumFromJSON,
    ListTypeEnumToJSON,
    ReqMatchConstraints,
    ReqMatchConstraintsFromJSON,
    ReqMatchConstraintsToJSON,
    ReqPatchSystem,
    ReqPatchSystemFromJSON,
    ReqPatchSystemToJSON,
    ReqPostSystem,
    ReqPostSystemFromJSON,
    ReqPostSystemToJSON,
    ReqPutSystem,
    ReqPutSystemFromJSON,
    ReqPutSystemToJSON,
    ReqSearchSystems,
    ReqSearchSystemsFromJSON,
    ReqSearchSystemsToJSON,
    RespBasic,
    RespBasicFromJSON,
    RespBasicToJSON,
    RespBoolean,
    RespBooleanFromJSON,
    RespBooleanToJSON,
    RespChangeCount,
    RespChangeCountFromJSON,
    RespChangeCountToJSON,
    RespResourceUrl,
    RespResourceUrlFromJSON,
    RespResourceUrlToJSON,
    RespSystem,
    RespSystemFromJSON,
    RespSystemToJSON,
    RespSystemHistory,
    RespSystemHistoryFromJSON,
    RespSystemHistoryToJSON,
    RespSystems,
    RespSystemsFromJSON,
    RespSystemsToJSON,
} from '../models';

export interface ChangeSystemOwnerRequest {
    systemId: string;
    userName: string;
}

export interface CreateSystemRequest {
    reqPostSystem: ReqPostSystem;
    skipCredentialCheck?: boolean;
}

export interface DeleteSystemRequest {
    systemId: string;
}

export interface DisableSystemRequest {
    systemId: string;
}

export interface EnableSystemRequest {
    systemId: string;
}

export interface GetHistoryRequest {
    systemId: string;
}

export interface GetSystemRequest {
    systemId: string;
    authnMethod?: string;
    requireExecPerm?: boolean;
    select?: string;
    returnCredentials?: boolean;
    impersonationId?: string;
    sharedAppCtx?: string;
    resourceTenant?: string;
}

export interface GetSystemsRequest {
    search?: string;
    listType?: ListTypeEnum;
    limit?: number;
    orderBy?: string;
    skip?: number;
    startAfter?: string;
    computeTotal?: boolean;
    select?: string;
    showDeleted?: boolean;
    impersonationId?: string;
}

export interface IsEnabledRequest {
    systemId: string;
}

export interface MatchConstraintsRequest {
    reqMatchConstraints: ReqMatchConstraints;
}

export interface PatchSystemRequest {
    systemId: string;
    reqPatchSystem: ReqPatchSystem;
}

export interface PutSystemRequest {
    systemId: string;
    reqPutSystem: ReqPutSystem;
    skipCredentialCheck?: boolean;
}

export interface SearchSystemsQueryParametersRequest {
    freeFormParameterName?: { [key: string]: string; };
    listType?: ListTypeEnum;
    limit?: number;
    orderBy?: string;
    skip?: number;
    startAfter?: string;
    computeTotal?: boolean;
    select?: string;
}

export interface SearchSystemsRequestBodyRequest {
    reqSearchSystems: ReqSearchSystems;
    listType?: ListTypeEnum;
    limit?: number;
    orderBy?: string;
    skip?: number;
    startAfter?: string;
    computeTotal?: boolean;
    select?: string;
}

export interface UndeleteSystemRequest {
    systemId: string;
}

/**
 * 
 */
export class SystemsApi extends runtime.BaseAPI {

    /**
     * Change owner of a system. 
     */
    async changeSystemOwnerRaw(requestParameters: ChangeSystemOwnerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling changeSystemOwner.');
        }

        if (requestParameters.userName === null || requestParameters.userName === undefined) {
            throw new runtime.RequiredError('userName','Required parameter requestParameters.userName was null or undefined when calling changeSystemOwner.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/{systemId}/changeOwner/{userName}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))).replace(`{${"userName"}}`, encodeURIComponent(String(requestParameters.userName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Change owner of a system. 
     */
    async changeSystemOwner(requestParameters: ChangeSystemOwnerRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.changeSystemOwnerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a system using a request body. System name must be unique within a tenant and can be composed of alphanumeric characters and the following special characters [-._~]. Name must begin with an alphanumeric character and can be no more than 80 characters in length. Description is optional with a maximum length of 2048 characters.  The attribute *host* represents a host name, IP address, Globus Endpoint Id or Globus Collection Id.  The attribute *effectiveUserId* determines the host login user, the user used to access the underlying host. The attribute can be set to a static string indicating a specific user (such as a service account) or dynamically specified as *${apiUserId}*. For the case of *${apiUserId}*, the service resolves the variable by extracting the identity from the request to the service (i.e. the JWT) and applying a mapping to a host login user if such a mapping has been provided. If no mapping is provided, then the extracted identity is taken to be the host login user.  If the *effectiveUserId* is static (i.e. not *${apiUserId}*) then credentials may optionally be provided in the *authnCredential* attribute of the request body. The Systems service does not store the secrets in its database, they are persisted in the Security Kernel.  By default for LINUX and S3 type systems credentials provided are verified. Use query parameter skipCredentialCheck=true to bypass initial verification of credentials.  The attribute *rootDir* serves as an effective root directory when operating on files through the Tapis Files service. All paths are relative to this directory when using Files to list, copy, move, mkdir, etc. Required for systems of type LINUX or IRODS. Supports the following variables which are resolved at create time: *${apiUserId}*, *${tenant}* and *${owner}*. May not be updated. Contact support to request a change.  There is also a special macro available for *rootDir* that may be used under certain conditions when a system is first created. The macro name is HOST_EVAL. The syntax for the macro is HOST_EVAL($var), where *var* is the environment variable to be evaluated on the system host when the create request is made. Note that the $ character preceding the environment variable name is optional. If after resolution the final path does not have the required leading slash (/) to make it an absolute path, then one will be prepended. The following conditions must be met in order to use the macro    - System must be of type LINUX   - Credentials must be provided when system is created.   - Macro HOST_EVAL() must only appear once and must be the first element of the path. Including a leading slash is optional.   - The *effectiveUserId* for the system must be static. Note that *effectiveUserId* may be set to *${owner}*.  Here are some examples    - HOST_EVAL($SCRATCH)   - HOST_EVAL($HOME)   - /HOST_EVAL(MY_ROOT_DIR)/scratch   - /HOST_EVAL($PROJECT_HOME)/projects/${tenant}/${owner}  Note that certain attributes in the request body (such as tenant) are allowed but ignored so that the JSON result returned by a GET may be modified and used when making a POST request to create a system. The attributes that are allowed but ignored are    - tenant   - uuid   - deleted   - created   - updated 
     */
    async createSystemRaw(requestParameters: CreateSystemRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespResourceUrl>> {
        if (requestParameters.reqPostSystem === null || requestParameters.reqPostSystem === undefined) {
            throw new runtime.RequiredError('reqPostSystem','Required parameter requestParameters.reqPostSystem was null or undefined when calling createSystem.');
        }

        const queryParameters: any = {};

        if (requestParameters.skipCredentialCheck !== undefined) {
            queryParameters['skipCredentialCheck'] = requestParameters.skipCredentialCheck;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqPostSystemToJSON(requestParameters.reqPostSystem),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespResourceUrlFromJSON(jsonValue));
    }

    /**
     * Create a system using a request body. System name must be unique within a tenant and can be composed of alphanumeric characters and the following special characters [-._~]. Name must begin with an alphanumeric character and can be no more than 80 characters in length. Description is optional with a maximum length of 2048 characters.  The attribute *host* represents a host name, IP address, Globus Endpoint Id or Globus Collection Id.  The attribute *effectiveUserId* determines the host login user, the user used to access the underlying host. The attribute can be set to a static string indicating a specific user (such as a service account) or dynamically specified as *${apiUserId}*. For the case of *${apiUserId}*, the service resolves the variable by extracting the identity from the request to the service (i.e. the JWT) and applying a mapping to a host login user if such a mapping has been provided. If no mapping is provided, then the extracted identity is taken to be the host login user.  If the *effectiveUserId* is static (i.e. not *${apiUserId}*) then credentials may optionally be provided in the *authnCredential* attribute of the request body. The Systems service does not store the secrets in its database, they are persisted in the Security Kernel.  By default for LINUX and S3 type systems credentials provided are verified. Use query parameter skipCredentialCheck=true to bypass initial verification of credentials.  The attribute *rootDir* serves as an effective root directory when operating on files through the Tapis Files service. All paths are relative to this directory when using Files to list, copy, move, mkdir, etc. Required for systems of type LINUX or IRODS. Supports the following variables which are resolved at create time: *${apiUserId}*, *${tenant}* and *${owner}*. May not be updated. Contact support to request a change.  There is also a special macro available for *rootDir* that may be used under certain conditions when a system is first created. The macro name is HOST_EVAL. The syntax for the macro is HOST_EVAL($var), where *var* is the environment variable to be evaluated on the system host when the create request is made. Note that the $ character preceding the environment variable name is optional. If after resolution the final path does not have the required leading slash (/) to make it an absolute path, then one will be prepended. The following conditions must be met in order to use the macro    - System must be of type LINUX   - Credentials must be provided when system is created.   - Macro HOST_EVAL() must only appear once and must be the first element of the path. Including a leading slash is optional.   - The *effectiveUserId* for the system must be static. Note that *effectiveUserId* may be set to *${owner}*.  Here are some examples    - HOST_EVAL($SCRATCH)   - HOST_EVAL($HOME)   - /HOST_EVAL(MY_ROOT_DIR)/scratch   - /HOST_EVAL($PROJECT_HOME)/projects/${tenant}/${owner}  Note that certain attributes in the request body (such as tenant) are allowed but ignored so that the JSON result returned by a GET may be modified and used when making a POST request to create a system. The attributes that are allowed but ignored are    - tenant   - uuid   - deleted   - created   - updated 
     */
    async createSystem(requestParameters: CreateSystemRequest, initOverrides?: RequestInit): Promise<RespResourceUrl> {
        const response = await this.createSystemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark a system as deleted. System will not appear in queries unless explicitly requested. 
     */
    async deleteSystemRaw(requestParameters: DeleteSystemRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling deleteSystem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/{systemId}/delete`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Mark a system as deleted. System will not appear in queries unless explicitly requested. 
     */
    async deleteSystem(requestParameters: DeleteSystemRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.deleteSystemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark a system unavailable for use. 
     */
    async disableSystemRaw(requestParameters: DisableSystemRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling disableSystem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/{systemId}/disable`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Mark a system unavailable for use. 
     */
    async disableSystem(requestParameters: DisableSystemRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.disableSystemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark a system available for use. 
     */
    async enableSystemRaw(requestParameters: EnableSystemRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling enableSystem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/{systemId}/enable`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Mark a system available for use. 
     */
    async enableSystem(requestParameters: EnableSystemRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.enableSystemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve history of changes for a given systemId. 
     */
    async getHistoryRaw(requestParameters: GetHistoryRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespSystemHistory>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling getHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/{systemId}/history`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespSystemHistoryFromJSON(jsonValue));
    }

    /**
     * Retrieve history of changes for a given systemId. 
     */
    async getHistory(requestParameters: GetHistoryRequest, initOverrides?: RequestInit): Promise<RespSystemHistory> {
        const response = await this.getHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve information for a system given the system Id.  Use query parameter *authnMethod* to override the default authentication method.  Certain Tapis services or a tenant administrator may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization and resolving the *effectiveUserId*.  Certain Tapis services may use the query parameter *sharedAppCtx* to indicate that the request is in a shared application context. 
     */
    async getSystemRaw(requestParameters: GetSystemRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespSystem>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling getSystem.');
        }

        const queryParameters: any = {};

        if (requestParameters.authnMethod !== undefined) {
            queryParameters['authnMethod'] = requestParameters.authnMethod;
        }

        if (requestParameters.requireExecPerm !== undefined) {
            queryParameters['requireExecPerm'] = requestParameters.requireExecPerm;
        }

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        if (requestParameters.returnCredentials !== undefined) {
            queryParameters['returnCredentials'] = requestParameters.returnCredentials;
        }

        if (requestParameters.impersonationId !== undefined) {
            queryParameters['impersonationId'] = requestParameters.impersonationId;
        }

        if (requestParameters.sharedAppCtx !== undefined) {
            queryParameters['sharedAppCtx'] = requestParameters.sharedAppCtx;
        }

        if (requestParameters.resourceTenant !== undefined) {
            queryParameters['resourceTenant'] = requestParameters.resourceTenant;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/{systemId}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespSystemFromJSON(jsonValue));
    }

    /**
     * Retrieve information for a system given the system Id.  Use query parameter *authnMethod* to override the default authentication method.  Certain Tapis services or a tenant administrator may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization and resolving the *effectiveUserId*.  Certain Tapis services may use the query parameter *sharedAppCtx* to indicate that the request is in a shared application context. 
     */
    async getSystem(requestParameters: GetSystemRequest, initOverrides?: RequestInit): Promise<RespSystem> {
        const response = await this.getSystemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve list of systems.  Use *listType*, *search* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission.  Certain Tapis services or a tenant administrator may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization and resolving the *effectiveUserId*. 
     */
    async getSystemsRaw(requestParameters: GetSystemsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespSystems>> {
        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.listType !== undefined) {
            queryParameters['listType'] = requestParameters.listType;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.skip !== undefined) {
            queryParameters['skip'] = requestParameters.skip;
        }

        if (requestParameters.startAfter !== undefined) {
            queryParameters['startAfter'] = requestParameters.startAfter;
        }

        if (requestParameters.computeTotal !== undefined) {
            queryParameters['computeTotal'] = requestParameters.computeTotal;
        }

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        if (requestParameters.showDeleted !== undefined) {
            queryParameters['showDeleted'] = requestParameters.showDeleted;
        }

        if (requestParameters.impersonationId !== undefined) {
            queryParameters['impersonationId'] = requestParameters.impersonationId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespSystemsFromJSON(jsonValue));
    }

    /**
     * Retrieve list of systems.  Use *listType*, *search* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission.  Certain Tapis services or a tenant administrator may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization and resolving the *effectiveUserId*. 
     */
    async getSystems(requestParameters: GetSystemsRequest, initOverrides?: RequestInit): Promise<RespSystems> {
        const response = await this.getSystemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check if a system is currently enabled, i.e. available for use. 
     */
    async isEnabledRaw(requestParameters: IsEnabledRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespBoolean>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling isEnabled.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/{systemId}/isEnabled`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespBooleanFromJSON(jsonValue));
    }

    /**
     * Check if a system is currently enabled, i.e. available for use. 
     */
    async isEnabled(requestParameters: IsEnabledRequest, initOverrides?: RequestInit): Promise<RespBoolean> {
        const response = await this.isEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * *WARNING Capability constraint matching is not yet supported.* Retrieve details for systems. Use request body to specify constraint conditions as an SQL-like WHERE clause. 
     */
    async matchConstraintsRaw(requestParameters: MatchConstraintsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespSystems>> {
        if (requestParameters.reqMatchConstraints === null || requestParameters.reqMatchConstraints === undefined) {
            throw new runtime.RequiredError('reqMatchConstraints','Required parameter requestParameters.reqMatchConstraints was null or undefined when calling matchConstraints.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/match/constraints`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqMatchConstraintsToJSON(requestParameters.reqMatchConstraints),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespSystemsFromJSON(jsonValue));
    }

    /**
     * *WARNING Capability constraint matching is not yet supported.* Retrieve details for systems. Use request body to specify constraint conditions as an SQL-like WHERE clause. 
     */
    async matchConstraints(requestParameters: MatchConstraintsRequest, initOverrides?: RequestInit): Promise<RespSystems> {
        const response = await this.matchConstraintsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update selected attributes of a system. Request body may only contain updatable attributes. System must exist.  Attributes that may not be updated via PATCH are    - id   - systemType   - owner   - enabled   - bucketName   - rootDir   - canExec  Note that the attributes owner and enabled may be modified using other endpoints. 
     */
    async patchSystemRaw(requestParameters: PatchSystemRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespResourceUrl>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling patchSystem.');
        }

        if (requestParameters.reqPatchSystem === null || requestParameters.reqPatchSystem === undefined) {
            throw new runtime.RequiredError('reqPatchSystem','Required parameter requestParameters.reqPatchSystem was null or undefined when calling patchSystem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/{systemId}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ReqPatchSystemToJSON(requestParameters.reqPatchSystem),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespResourceUrlFromJSON(jsonValue));
    }

    /**
     * Update selected attributes of a system. Request body may only contain updatable attributes. System must exist.  Attributes that may not be updated via PATCH are    - id   - systemType   - owner   - enabled   - bucketName   - rootDir   - canExec  Note that the attributes owner and enabled may be modified using other endpoints. 
     */
    async patchSystem(requestParameters: PatchSystemRequest, initOverrides?: RequestInit): Promise<RespResourceUrl> {
        const response = await this.patchSystemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update all updatable attributes of a system using a request body identical to POST. System must exist.  Note that certain attributes in the request body (such as tenant) are allowed but ignored so that the JSON result returned by a GET may be modified and used when making a PUT request to update a system.  The attributes that are allowed but ignored for both PUT and POST are    - tenant   - uuid   - deleted   - created   - updated  In addition for a PUT operation the following non-updatable attributes are allowed but ignored    - id   - systemType   - owner   - effectiveUserId   - authnCredential   - enabled   - bucketName   - rootDir   - canExec  Note that the attributes *owner*, *enabled* and *authnCredential* may be modified using other endpoints. Attribute *effectiveUserId* may be updated using the endpoint **patchSystem**. 
     */
    async putSystemRaw(requestParameters: PutSystemRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespResourceUrl>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling putSystem.');
        }

        if (requestParameters.reqPutSystem === null || requestParameters.reqPutSystem === undefined) {
            throw new runtime.RequiredError('reqPutSystem','Required parameter requestParameters.reqPutSystem was null or undefined when calling putSystem.');
        }

        const queryParameters: any = {};

        if (requestParameters.skipCredentialCheck !== undefined) {
            queryParameters['skipCredentialCheck'] = requestParameters.skipCredentialCheck;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/{systemId}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ReqPutSystemToJSON(requestParameters.reqPutSystem),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespResourceUrlFromJSON(jsonValue));
    }

    /**
     * Update all updatable attributes of a system using a request body identical to POST. System must exist.  Note that certain attributes in the request body (such as tenant) are allowed but ignored so that the JSON result returned by a GET may be modified and used when making a PUT request to update a system.  The attributes that are allowed but ignored for both PUT and POST are    - tenant   - uuid   - deleted   - created   - updated  In addition for a PUT operation the following non-updatable attributes are allowed but ignored    - id   - systemType   - owner   - effectiveUserId   - authnCredential   - enabled   - bucketName   - rootDir   - canExec  Note that the attributes *owner*, *enabled* and *authnCredential* may be modified using other endpoints. Attribute *effectiveUserId* may be updated using the endpoint **patchSystem**. 
     */
    async putSystem(requestParameters: PutSystemRequest, initOverrides?: RequestInit): Promise<RespResourceUrl> {
        const response = await this.putSystemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve details for systems. Use query parameters to specify search conditions. For example owner.eq=jdoe&port.gt=1024 Use *listType* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. 
     */
    async searchSystemsQueryParametersRaw(requestParameters: SearchSystemsQueryParametersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespSystems>> {
        const queryParameters: any = {};

        if (requestParameters.freeFormParameterName !== undefined) {
            queryParameters['freeFormParameterName'] = requestParameters.freeFormParameterName;
        }

        if (requestParameters.listType !== undefined) {
            queryParameters['listType'] = requestParameters.listType;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.skip !== undefined) {
            queryParameters['skip'] = requestParameters.skip;
        }

        if (requestParameters.startAfter !== undefined) {
            queryParameters['startAfter'] = requestParameters.startAfter;
        }

        if (requestParameters.computeTotal !== undefined) {
            queryParameters['computeTotal'] = requestParameters.computeTotal;
        }

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespSystemsFromJSON(jsonValue));
    }

    /**
     * Retrieve details for systems. Use query parameters to specify search conditions. For example owner.eq=jdoe&port.gt=1024 Use *listType* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. 
     */
    async searchSystemsQueryParameters(requestParameters: SearchSystemsQueryParametersRequest, initOverrides?: RequestInit): Promise<RespSystems> {
        const response = await this.searchSystemsQueryParametersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve details for systems. Use request body to specify SQL-like search conditions. Use *listType* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. 
     */
    async searchSystemsRequestBodyRaw(requestParameters: SearchSystemsRequestBodyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespSystems>> {
        if (requestParameters.reqSearchSystems === null || requestParameters.reqSearchSystems === undefined) {
            throw new runtime.RequiredError('reqSearchSystems','Required parameter requestParameters.reqSearchSystems was null or undefined when calling searchSystemsRequestBody.');
        }

        const queryParameters: any = {};

        if (requestParameters.listType !== undefined) {
            queryParameters['listType'] = requestParameters.listType;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.skip !== undefined) {
            queryParameters['skip'] = requestParameters.skip;
        }

        if (requestParameters.startAfter !== undefined) {
            queryParameters['startAfter'] = requestParameters.startAfter;
        }

        if (requestParameters.computeTotal !== undefined) {
            queryParameters['computeTotal'] = requestParameters.computeTotal;
        }

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqSearchSystemsToJSON(requestParameters.reqSearchSystems),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespSystemsFromJSON(jsonValue));
    }

    /**
     * Retrieve details for systems. Use request body to specify SQL-like search conditions. Use *listType* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. 
     */
    async searchSystemsRequestBody(requestParameters: SearchSystemsRequestBodyRequest, initOverrides?: RequestInit): Promise<RespSystems> {
        const response = await this.searchSystemsRequestBodyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark a system as not deleted. System will appear in queries. 
     */
    async undeleteSystemRaw(requestParameters: UndeleteSystemRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling undeleteSystem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/systems/{systemId}/undelete`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Mark a system as not deleted. System will appear in queries. 
     */
    async undeleteSystem(requestParameters: UndeleteSystemRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.undeleteSystemRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
