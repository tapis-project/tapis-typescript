/* tslint:disable */
/* eslint-disable */
/**
 * Tapis Pods Service
 *  The Pods Service is a web service and distributed computing platform providing pods-as-a-service (PaaS). The service  implements a message broker and processor model that requests pods, alongside a health module to poll for pod data, including logs, status, and health. The primary use of this service is to have quick to deploy long-lived services based on Docker images that are exposed via HTTP or TCP endpoints listed by the API.  **The Pods service provides functionality for two types of pod solutions:**  * **Templated Pods** for run-as-is popular images. Neo4J is one example, the template manages TCP ports, user creation, and permissions.  * **Custom Pods** for arbitrary docker images with less functionality. In this case we will expose port 5000 and do nothing else.   The live-docs act as the most up-to-date API reference. Visit the [documentation for more information](https://tapis.readthedocs.io/en/latest/technical/pods.html). 
 *
 * The version of the OpenAPI document: 1.8.4
 * Contact: cicsupport@tacc.utexas.edu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ExecutePodCommands,
    ExecutePodCommandsFromJSON,
    ExecutePodCommandsToJSON,
    HTTPValidationError,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    NewPod,
    NewPodFromJSON,
    NewPodToJSON,
    NewTemplateTagFromPod,
    NewTemplateTagFromPodFromJSON,
    NewTemplateTagFromPodToJSON,
    PodCredentialsResponse,
    PodCredentialsResponseFromJSON,
    PodCredentialsResponseToJSON,
    PodDeleteResponse,
    PodDeleteResponseFromJSON,
    PodDeleteResponseToJSON,
    PodLogsResponse,
    PodLogsResponseFromJSON,
    PodLogsResponseToJSON,
    PodResponse,
    PodResponseFromJSON,
    PodResponseToJSON,
    PodsResponse,
    PodsResponseFromJSON,
    PodsResponseToJSON,
    TemplateTagResponse,
    TemplateTagResponseFromJSON,
    TemplateTagResponseToJSON,
    UpdatePod,
    UpdatePodFromJSON,
    UpdatePodToJSON,
} from '../models';

export interface CreatePodRequest {
    newPod: NewPod;
}

export interface DeletePodRequest {
    podId: any;
}

export interface ExecPodCommandsRequest {
    podId: any;
    executePodCommands: ExecutePodCommands;
}

export interface GetDerivedPodRequest {
    podId: any;
}

export interface GetPodRequest {
    podId: any;
}

export interface GetPodCredentialsRequest {
    podId: any;
}

export interface GetPodLogsRequest {
    podId: any;
}

export interface PodAuthRequest {
    podIdNet: any;
}

export interface PodAuthCallbackRequest {
    podIdNet: any;
}

export interface RestartPodRequest {
    podId: any;
    grabLatestTemplateTag?: boolean;
}

export interface SavePodAsTemplateTagRequest {
    podIdNet: any;
    newTemplateTagFromPod: NewTemplateTagFromPod;
}

export interface StartPodRequest {
    podId: any;
}

export interface StopPodRequest {
    podId: any;
}

export interface UpdatePodRequest {
    podId: any;
    updatePod: UpdatePod;
}

export interface UploadToPodRequest {
    podId: string;
    file: Blob;
    destPath: string;
}

/**
 * 
 */
export class PodsApi extends runtime.BaseAPI {

    /**
     * Create a pod with inputted information.  Notes: - Author will be given ADMIN level permissions to the pod. - status_requested defaults to \"ON\". So pod will immediately begin creation.  Returns new pod object.
     * create_pod
     */
    async createPodRaw(requestParameters: CreatePodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodResponse>> {
        if (requestParameters.newPod === null || requestParameters.newPod === undefined) {
            throw new runtime.RequiredError('newPod','Required parameter requestParameters.newPod was null or undefined when calling createPod.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v3/pods`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewPodToJSON(requestParameters.newPod),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodResponseFromJSON(jsonValue));
    }

    /**
     * Create a pod with inputted information.  Notes: - Author will be given ADMIN level permissions to the pod. - status_requested defaults to \"ON\". So pod will immediately begin creation.  Returns new pod object.
     * create_pod
     */
    async createPod(requestParameters: CreatePodRequest, initOverrides?: RequestInit): Promise<PodResponse> {
        const response = await this.createPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a pod.  Returns \"\".
     * delete_pod
     */
    async deletePodRaw(requestParameters: DeletePodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodDeleteResponse>> {
        if (requestParameters.podId === null || requestParameters.podId === undefined) {
            throw new runtime.RequiredError('podId','Required parameter requestParameters.podId was null or undefined when calling deletePod.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/pods/{pod_id}`.replace(`{${"pod_id"}}`, encodeURIComponent(String(requestParameters.podId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodDeleteResponseFromJSON(jsonValue));
    }

    /**
     * Delete a pod.  Returns \"\".
     * delete_pod
     */
    async deletePod(requestParameters: DeletePodRequest, initOverrides?: RequestInit): Promise<PodDeleteResponse> {
        const response = await this.deletePodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Execute one or more commands in a pod.  Accepts either: - Single command: [\"sleep\", \"5\"] - Multiple commands: [[\"sleep\", \"5\"], [\"echo\", \"hello\"]]  Executes commands synchronously in the pod: - Each command runs sequentially - Total request time = sum of all command execution times - Request remains open until all commands complete - Returns consolidated results for all commands  Response includes: - Individual command outputs - Success/failure status - Execution duration
     * exec_pod_commands
     */
    async execPodCommandsRaw(requestParameters: ExecPodCommandsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.podId === null || requestParameters.podId === undefined) {
            throw new runtime.RequiredError('podId','Required parameter requestParameters.podId was null or undefined when calling execPodCommands.');
        }

        if (requestParameters.executePodCommands === null || requestParameters.executePodCommands === undefined) {
            throw new runtime.RequiredError('executePodCommands','Required parameter requestParameters.executePodCommands was null or undefined when calling execPodCommands.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v3/pods/{pod_id}/exec`.replace(`{${"pod_id"}}`, encodeURIComponent(String(requestParameters.podId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExecutePodCommandsToJSON(requestParameters.executePodCommands),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Execute one or more commands in a pod.  Accepts either: - Single command: [\"sleep\", \"5\"] - Multiple commands: [[\"sleep\", \"5\"], [\"echo\", \"hello\"]]  Executes commands synchronously in the pod: - Each command runs sequentially - Total request time = sum of all command execution times - Request remains open until all commands complete - Returns consolidated results for all commands  Response includes: - Individual command outputs - Success/failure status - Execution duration
     * exec_pod_commands
     */
    async execPodCommands(requestParameters: ExecPodCommandsRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.execPodCommandsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Derive a pod\'s final definition if templates are used.  Returns final pod definition to be used for pod creation.
     * get_derived_pod
     */
    async getDerivedPodRaw(requestParameters: GetDerivedPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodResponse>> {
        if (requestParameters.podId === null || requestParameters.podId === undefined) {
            throw new runtime.RequiredError('podId','Required parameter requestParameters.podId was null or undefined when calling getDerivedPod.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/pods/{pod_id}/derived`.replace(`{${"pod_id"}}`, encodeURIComponent(String(requestParameters.podId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodResponseFromJSON(jsonValue));
    }

    /**
     * Derive a pod\'s final definition if templates are used.  Returns final pod definition to be used for pod creation.
     * get_derived_pod
     */
    async getDerivedPod(requestParameters: GetDerivedPodRequest, initOverrides?: RequestInit): Promise<PodResponse> {
        const response = await this.getDerivedPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a pod.  Returns retrieved pod object.
     * get_pod
     */
    async getPodRaw(requestParameters: GetPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodResponse>> {
        if (requestParameters.podId === null || requestParameters.podId === undefined) {
            throw new runtime.RequiredError('podId','Required parameter requestParameters.podId was null or undefined when calling getPod.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/pods/{pod_id}`.replace(`{${"pod_id"}}`, encodeURIComponent(String(requestParameters.podId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodResponseFromJSON(jsonValue));
    }

    /**
     * Get a pod.  Returns retrieved pod object.
     * get_pod
     */
    async getPod(requestParameters: GetPodRequest, initOverrides?: RequestInit): Promise<PodResponse> {
        const response = await this.getPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the credentials created for a pod.  Note: - These credentials are used in the case of templated pods, but for custom pods they\'re not.  Returns user accessible credentials.
     * get_pod_credentials
     */
    async getPodCredentialsRaw(requestParameters: GetPodCredentialsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodCredentialsResponse>> {
        if (requestParameters.podId === null || requestParameters.podId === undefined) {
            throw new runtime.RequiredError('podId','Required parameter requestParameters.podId was null or undefined when calling getPodCredentials.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/pods/{pod_id}/credentials`.replace(`{${"pod_id"}}`, encodeURIComponent(String(requestParameters.podId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodCredentialsResponseFromJSON(jsonValue));
    }

    /**
     * Get the credentials created for a pod.  Note: - These credentials are used in the case of templated pods, but for custom pods they\'re not.  Returns user accessible credentials.
     * get_pod_credentials
     */
    async getPodCredentials(requestParameters: GetPodCredentialsRequest, initOverrides?: RequestInit): Promise<PodCredentialsResponse> {
        const response = await this.getPodCredentialsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a pods stdout logs and action_logs.  Note: - Pod logs are only retrieved while pod is running. - If a pod is restarted or turned off and then on, the logs will be reset. - Action logs are detailed logs of actions taken on the pod.  Returns pod stdout logs and action logs.
     * get_pod_logs
     */
    async getPodLogsRaw(requestParameters: GetPodLogsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodLogsResponse>> {
        if (requestParameters.podId === null || requestParameters.podId === undefined) {
            throw new runtime.RequiredError('podId','Required parameter requestParameters.podId was null or undefined when calling getPodLogs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/pods/{pod_id}/logs`.replace(`{${"pod_id"}}`, encodeURIComponent(String(requestParameters.podId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodLogsResponseFromJSON(jsonValue));
    }

    /**
     * Get a pods stdout logs and action_logs.  Note: - Pod logs are only retrieved while pod is running. - If a pod is restarted or turned off and then on, the logs will be reset. - Action logs are detailed logs of actions taken on the pod.  Returns pod stdout logs and action logs.
     * get_pod_logs
     */
    async getPodLogs(requestParameters: GetPodLogsRequest, initOverrides?: RequestInit): Promise<PodLogsResponse> {
        const response = await this.getPodLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all pods in your respective tenant and site that you have READ or higher access to.  Returns a list of pods.
     * list_pods
     */
    async listPodsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/pods`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodsResponseFromJSON(jsonValue));
    }

    /**
     * Get all pods in your respective tenant and site that you have READ or higher access to.  Returns a list of pods.
     * list_pods
     */
    async listPods(initOverrides?: RequestInit): Promise<PodsResponse> {
        const response = await this.listPodsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Auth endpoint for each pod. When a networking object defines tapis_auth=True, this endpoint manages auth.  Traefik has a forwardAuth middleware for http routes. This redirects users, auth happens, if traefik gets 200 then traefik allows user to endpoint. Auth flow for a user getting to \"fastapi hello world\" pod at https://fastapi.pods.tacc.tapis.io.   1) User navigates to https://fastapi.pods.tacc.tapis.io   2) Traefik redirects user to https://tacc.tapis.io/v3/pods/fastapi/auth   3) Check if logged in via cookies, if logged in, respond 200 + set user defined headers. Otherwise...   4) Pods service creates client in correct tenant for user or updates client if it already exists. (we expect only one client in use at a time)   5) With client the /auth endpoint redirects users to https://tacc.tapis.io/v3/oauth2/authorize?client_id={client_id}&redirect_uri={callback_url}&response_type=code   6) User logs in via browser, authorizes client, redirects to callback_url at https://tacc.tapis.io/v3/pods/fastapi/auth/callback?code=CodeHere   7) Callback url exchanges code for token, gets username from token, sets X-Tapis-Token cookies, sets response headers according to tapis_auth_response_headers   8) User gets redirected back to https://fastapi.pods.tacc.tapis.io/{tapis_auth_return_path}, Traefik starts forwardAuth, user at this point should be authenticated   9) Auth endpoint responds with 200, sets headers specified by networking stanza, and users gets to fastapi hello world response.  users can specify:  - tapis_auth=True/False - Turns on auth  - tapis_auth_response_headers - dict[str] - headers to set on response and their values  - tapis_auth_allowed_users - list[str] - list of tapis users allowed to access pod  - tapis_auth_return_path - str - uri to return to after auth, default is \"passthrough\", which we save in cookies(?) and return to. x-forwarded-host?   - response headers need to be slightly modifiable to allow for different application requirements  - for example we have to pass username, but many apps require @email.bit, so user must be able to append to user.  - tapis_auth_response_headers: {\"X-Tapis-Username\": \"<<tapisusername>>@tapis.io\", \"FROM\": \"pods auth endpoint from <<tenant>>.<<site>>\", \"OAUTH2_USERNAME_KEY\": \"username\"}   - tapis_auth_allowed_users, checks username against .lower() of username list to make sure it\'s in list. otherwise deny
     * pod_auth
     */
    async podAuthRaw(requestParameters: PodAuthRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodResponse>> {
        if (requestParameters.podIdNet === null || requestParameters.podIdNet === undefined) {
            throw new runtime.RequiredError('podIdNet','Required parameter requestParameters.podIdNet was null or undefined when calling podAuth.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/pods/{pod_id_net}/auth`.replace(`{${"pod_id_net"}}`, encodeURIComponent(String(requestParameters.podIdNet))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodResponseFromJSON(jsonValue));
    }

    /**
     * Auth endpoint for each pod. When a networking object defines tapis_auth=True, this endpoint manages auth.  Traefik has a forwardAuth middleware for http routes. This redirects users, auth happens, if traefik gets 200 then traefik allows user to endpoint. Auth flow for a user getting to \"fastapi hello world\" pod at https://fastapi.pods.tacc.tapis.io.   1) User navigates to https://fastapi.pods.tacc.tapis.io   2) Traefik redirects user to https://tacc.tapis.io/v3/pods/fastapi/auth   3) Check if logged in via cookies, if logged in, respond 200 + set user defined headers. Otherwise...   4) Pods service creates client in correct tenant for user or updates client if it already exists. (we expect only one client in use at a time)   5) With client the /auth endpoint redirects users to https://tacc.tapis.io/v3/oauth2/authorize?client_id={client_id}&redirect_uri={callback_url}&response_type=code   6) User logs in via browser, authorizes client, redirects to callback_url at https://tacc.tapis.io/v3/pods/fastapi/auth/callback?code=CodeHere   7) Callback url exchanges code for token, gets username from token, sets X-Tapis-Token cookies, sets response headers according to tapis_auth_response_headers   8) User gets redirected back to https://fastapi.pods.tacc.tapis.io/{tapis_auth_return_path}, Traefik starts forwardAuth, user at this point should be authenticated   9) Auth endpoint responds with 200, sets headers specified by networking stanza, and users gets to fastapi hello world response.  users can specify:  - tapis_auth=True/False - Turns on auth  - tapis_auth_response_headers - dict[str] - headers to set on response and their values  - tapis_auth_allowed_users - list[str] - list of tapis users allowed to access pod  - tapis_auth_return_path - str - uri to return to after auth, default is \"passthrough\", which we save in cookies(?) and return to. x-forwarded-host?   - response headers need to be slightly modifiable to allow for different application requirements  - for example we have to pass username, but many apps require @email.bit, so user must be able to append to user.  - tapis_auth_response_headers: {\"X-Tapis-Username\": \"<<tapisusername>>@tapis.io\", \"FROM\": \"pods auth endpoint from <<tenant>>.<<site>>\", \"OAUTH2_USERNAME_KEY\": \"username\"}   - tapis_auth_allowed_users, checks username against .lower() of username list to make sure it\'s in list. otherwise deny
     * pod_auth
     */
    async podAuth(requestParameters: PodAuthRequest, initOverrides?: RequestInit): Promise<PodResponse> {
        const response = await this.podAuthRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * pod_auth_callback
     */
    async podAuthCallbackRaw(requestParameters: PodAuthCallbackRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodResponse>> {
        if (requestParameters.podIdNet === null || requestParameters.podIdNet === undefined) {
            throw new runtime.RequiredError('podIdNet','Required parameter requestParameters.podIdNet was null or undefined when calling podAuthCallback.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/pods/{pod_id_net}/auth/callback`.replace(`{${"pod_id_net"}}`, encodeURIComponent(String(requestParameters.podIdNet))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodResponseFromJSON(jsonValue));
    }

    /**
     * pod_auth_callback
     */
    async podAuthCallback(requestParameters: PodAuthCallbackRequest, initOverrides?: RequestInit): Promise<PodResponse> {
        const response = await this.podAuthCallbackRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restart a pod.  Note: - Sets status_requested to RESTART. If pod status gets to STOPPED, status_requested will be flipped to ON. Health should then create new pod. - If grab_latest_template_tag is True, attempts to grab the latest version of the template tag if the pod has a template.  Returns updated pod object.
     * restart_pod
     */
    async restartPodRaw(requestParameters: RestartPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodResponse>> {
        if (requestParameters.podId === null || requestParameters.podId === undefined) {
            throw new runtime.RequiredError('podId','Required parameter requestParameters.podId was null or undefined when calling restartPod.');
        }

        const queryParameters: any = {};

        if (requestParameters.grabLatestTemplateTag !== undefined) {
            queryParameters['grab_latest_template_tag'] = requestParameters.grabLatestTemplateTag;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/pods/{pod_id}/restart`.replace(`{${"pod_id"}}`, encodeURIComponent(String(requestParameters.podId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodResponseFromJSON(jsonValue));
    }

    /**
     * Restart a pod.  Note: - Sets status_requested to RESTART. If pod status gets to STOPPED, status_requested will be flipped to ON. Health should then create new pod. - If grab_latest_template_tag is True, attempts to grab the latest version of the template tag if the pod has a template.  Returns updated pod object.
     * restart_pod
     */
    async restartPod(requestParameters: RestartPodRequest, initOverrides?: RequestInit): Promise<PodResponse> {
        const response = await this.restartPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Endpoint takes pod_id and derives a pod_definition to create a template tag from it. Allows users to save the configuration of a particular pod as a template tag.  POST data contains location to save the tag and tag creation data  Return the template tag object.
     * save_pod_as_template_tag
     */
    async savePodAsTemplateTagRaw(requestParameters: SavePodAsTemplateTagRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TemplateTagResponse>> {
        if (requestParameters.podIdNet === null || requestParameters.podIdNet === undefined) {
            throw new runtime.RequiredError('podIdNet','Required parameter requestParameters.podIdNet was null or undefined when calling savePodAsTemplateTag.');
        }

        if (requestParameters.newTemplateTagFromPod === null || requestParameters.newTemplateTagFromPod === undefined) {
            throw new runtime.RequiredError('newTemplateTagFromPod','Required parameter requestParameters.newTemplateTagFromPod was null or undefined when calling savePodAsTemplateTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v3/pods/{pod_id_net}/save_pod_as_template_tag`.replace(`{${"pod_id_net"}}`, encodeURIComponent(String(requestParameters.podIdNet))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewTemplateTagFromPodToJSON(requestParameters.newTemplateTagFromPod),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TemplateTagResponseFromJSON(jsonValue));
    }

    /**
     * Endpoint takes pod_id and derives a pod_definition to create a template tag from it. Allows users to save the configuration of a particular pod as a template tag.  POST data contains location to save the tag and tag creation data  Return the template tag object.
     * save_pod_as_template_tag
     */
    async savePodAsTemplateTag(requestParameters: SavePodAsTemplateTagRequest, initOverrides?: RequestInit): Promise<TemplateTagResponse> {
        const response = await this.savePodAsTemplateTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Start a pod.  Note: - Sets status_requested to ON. Pod will attempt to deploy.  Returns updated pod object.
     * start_pod
     */
    async startPodRaw(requestParameters: StartPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodResponse>> {
        if (requestParameters.podId === null || requestParameters.podId === undefined) {
            throw new runtime.RequiredError('podId','Required parameter requestParameters.podId was null or undefined when calling startPod.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/pods/{pod_id}/start`.replace(`{${"pod_id"}}`, encodeURIComponent(String(requestParameters.podId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodResponseFromJSON(jsonValue));
    }

    /**
     * Start a pod.  Note: - Sets status_requested to ON. Pod will attempt to deploy.  Returns updated pod object.
     * start_pod
     */
    async startPod(requestParameters: StartPodRequest, initOverrides?: RequestInit): Promise<PodResponse> {
        const response = await this.startPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stop a pod.  Note: - Sets status_requested to OFF. Pod will attempt to get to STOPPED status unless start_pod is ran.  Returns updated pod object.
     * stop_pod
     */
    async stopPodRaw(requestParameters: StopPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodResponse>> {
        if (requestParameters.podId === null || requestParameters.podId === undefined) {
            throw new runtime.RequiredError('podId','Required parameter requestParameters.podId was null or undefined when calling stopPod.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/pods/{pod_id}/stop`.replace(`{${"pod_id"}}`, encodeURIComponent(String(requestParameters.podId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodResponseFromJSON(jsonValue));
    }

    /**
     * Stop a pod.  Note: - Sets status_requested to OFF. Pod will attempt to get to STOPPED status unless start_pod is ran.  Returns updated pod object.
     * stop_pod
     */
    async stopPod(requestParameters: StopPodRequest, initOverrides?: RequestInit): Promise<PodResponse> {
        const response = await this.stopPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a pod.  Note: - Pod will not be restarted, you must restart the pod for any pod-related changes to proliferate.  Returns updated pod object.
     * update_pod
     */
    async updatePodRaw(requestParameters: UpdatePodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<PodResponse>> {
        if (requestParameters.podId === null || requestParameters.podId === undefined) {
            throw new runtime.RequiredError('podId','Required parameter requestParameters.podId was null or undefined when calling updatePod.');
        }

        if (requestParameters.updatePod === null || requestParameters.updatePod === undefined) {
            throw new runtime.RequiredError('updatePod','Required parameter requestParameters.updatePod was null or undefined when calling updatePod.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v3/pods/{pod_id}`.replace(`{${"pod_id"}}`, encodeURIComponent(String(requestParameters.podId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdatePodToJSON(requestParameters.updatePod),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PodResponseFromJSON(jsonValue));
    }

    /**
     * Update a pod.  Note: - Pod will not be restarted, you must restart the pod for any pod-related changes to proliferate.  Returns updated pod object.
     * update_pod
     */
    async updatePod(requestParameters: UpdatePodRequest, initOverrides?: RequestInit): Promise<PodResponse> {
        const response = await this.updatePodRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a file to a specific path inside the pod using Kubernetes exec/copy (chunked streaming, no temp file).
     * Upload a file directly into the pod\'s filesystem
     */
    async uploadToPodRaw(requestParameters: UploadToPodRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.podId === null || requestParameters.podId === undefined) {
            throw new runtime.RequiredError('podId','Required parameter requestParameters.podId was null or undefined when calling uploadToPod.');
        }

        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling uploadToPod.');
        }

        if (requestParameters.destPath === null || requestParameters.destPath === undefined) {
            throw new runtime.RequiredError('destPath','Required parameter requestParameters.destPath was null or undefined when calling uploadToPod.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.destPath !== undefined) {
            formParams.append('dest_path', requestParameters.destPath as any);
        }

        const response = await this.request({
            path: `/v3/pods/{pod_id}/upload_to_pod`.replace(`{${"pod_id"}}`, encodeURIComponent(String(requestParameters.podId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Upload a file to a specific path inside the pod using Kubernetes exec/copy (chunked streaming, no temp file).
     * Upload a file directly into the pod\'s filesystem
     */
    async uploadToPod(requestParameters: UploadToPodRequest, initOverrides?: RequestInit): Promise<any> {
        const response = await this.uploadToPodRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
