/* tslint:disable */
/* eslint-disable */
/**
 * Tapis Files API
 * The Tapis Files API provides for management of file resources on Tapis systems
 *
 * The version of the OpenAPI document: 1.3.6
 * Contact: cicsupport@tacc.utexas.edu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    FileListingResponse,
    FileListingResponseFromJSON,
    FileListingResponseToJSON,
    FileStatInfoResponse,
    FileStatInfoResponseFromJSON,
    FileStatInfoResponseToJSON,
    FileStringResponse,
    FileStringResponseFromJSON,
    FileStringResponseToJSON,
    MkdirRequest,
    MkdirRequestFromJSON,
    MkdirRequestToJSON,
    MoveCopyRequest,
    MoveCopyRequestFromJSON,
    MoveCopyRequestToJSON,
    NativeLinuxGetFaclResponse,
    NativeLinuxGetFaclResponseFromJSON,
    NativeLinuxGetFaclResponseToJSON,
    NativeLinuxOpRequest,
    NativeLinuxOpRequestFromJSON,
    NativeLinuxOpRequestToJSON,
    NativeLinuxOpResultResponse,
    NativeLinuxOpResultResponseFromJSON,
    NativeLinuxOpResultResponseToJSON,
    NativeLinuxSetFaclRequest,
    NativeLinuxSetFaclRequestFromJSON,
    NativeLinuxSetFaclRequestToJSON,
    NativeLinuxSetFaclResponse,
    NativeLinuxSetFaclResponseFromJSON,
    NativeLinuxSetFaclResponseToJSON,
} from '../models';

export interface DeleteRequest {
    systemId: string;
    path: string;
}

export interface GetFaclRequest {
    systemId: string;
    path: string;
}

export interface GetStatInfoRequest {
    systemId: string;
    path: string;
    followLinks?: boolean;
}

export interface InsertRequest {
    systemId: string;
    path: string;
    file: Blob;
}

export interface ListFilesRequest {
    systemId: string;
    path: string;
    limit?: number;
    offset?: number;
    recurse?: boolean;
    impersonationId?: string;
    sharedCtx?: string;
}

export interface MkdirOperationRequest {
    systemId: string;
    sharedCtx?: string;
    mkdirRequest?: MkdirRequest;
}

export interface MoveCopyOperationRequest {
    systemId: string;
    path: string;
    moveCopyRequest?: MoveCopyRequest;
}

export interface RunLinuxNativeOpRequest {
    systemId: string;
    path: string;
    recursive?: boolean;
    nativeLinuxOpRequest?: NativeLinuxOpRequest;
}

export interface SetFaclRequest {
    systemId: string;
    path: string;
    nativeLinuxSetFaclRequest: NativeLinuxSetFaclRequest;
}

/**
 * 
 */
export class FileOperationsApi extends runtime.BaseAPI {

    /**
     * Delete a file, directory or object on {systemID} at path {path}.  For a LINUX directory this will be a recursive delete.  For an S3 system, the path will represent either a single object or all objects in the bucket with a prefix matching the system *rootDir* if the path is the empty string.  **WARNING** For an S3 system if the path is the empty string, then all objects in the bucket with a key matching the prefix *rootDir* will be deleted. So if the *rootDir* is also the empty string, then all objects in the bucket will be removed. 
     */
    async _deleteRaw(requestParameters: DeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FileStringResponse>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling _delete.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling _delete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/files/ops/{systemId}/{path}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileStringResponseFromJSON(jsonValue));
    }

    /**
     * Delete a file, directory or object on {systemID} at path {path}.  For a LINUX directory this will be a recursive delete.  For an S3 system, the path will represent either a single object or all objects in the bucket with a prefix matching the system *rootDir* if the path is the empty string.  **WARNING** For an S3 system if the path is the empty string, then all objects in the bucket with a key matching the prefix *rootDir* will be deleted. So if the *rootDir* is also the empty string, then all objects in the bucket will be removed. 
     */
    async _delete(requestParameters: DeleteRequest, initOverrides?: RequestInit): Promise<FileStringResponse> {
        const response = await this._deleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get file ACLs for files or directories for a system of type LINUX. 
     */
    async getFaclRaw(requestParameters: GetFaclRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<NativeLinuxGetFaclResponse>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling getFacl.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling getFacl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/files/utils/linux/facl/{systemId}/{path}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NativeLinuxGetFaclResponseFromJSON(jsonValue));
    }

    /**
     * Get file ACLs for files or directories for a system of type LINUX. 
     */
    async getFacl(requestParameters: GetFaclRequest, initOverrides?: RequestInit): Promise<NativeLinuxGetFaclResponse> {
        const response = await this.getFaclRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get native stat information for a file or directory for a system of type LINUX. 
     */
    async getStatInfoRaw(requestParameters: GetStatInfoRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FileStatInfoResponse>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling getStatInfo.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling getStatInfo.');
        }

        const queryParameters: any = {};

        if (requestParameters.followLinks !== undefined) {
            queryParameters['followLinks'] = requestParameters.followLinks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/files/utils/linux/{systemId}/{path}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileStatInfoResponseFromJSON(jsonValue));
    }

    /**
     * Get native stat information for a file or directory for a system of type LINUX. 
     */
    async getStatInfo(requestParameters: GetStatInfoRequest, initOverrides?: RequestInit): Promise<FileStatInfoResponse> {
        const response = await this.getStatInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The file or object will be uploaded at the {path} independent of the original name. 
     */
    async insertRaw(requestParameters: InsertRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FileStringResponse>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling insert.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling insert.');
        }

        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling insert.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        const response = await this.request({
            path: `/v3/files/ops/{systemId}/{path}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileStringResponseFromJSON(jsonValue));
    }

    /**
     * The file or object will be uploaded at the {path} independent of the original name. 
     */
    async insert(requestParameters: InsertRequest, initOverrides?: RequestInit): Promise<FileStringResponse> {
        const response = await this.insertRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List files or objects on a Tapis system. Type for items will depend on system type. For example, for LINUX they will be posix files and for S3 they will be storage objects. For S3 the recurse flag is ignored and all objects with keys matching the path as a prefix are included.  For system types that support directory hierarchies the maximum recursion depth is 20.  Note that S3 buckets do not have a hierarchical structure. There are no directories. Everything is an object associated with a key.  Certain services may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization and resolving the *effectiveUserId* for the system.  Certain services may use the query parameter *sharedCtx* to indicate that the request is in a shared context. *sharedCtx* must be set to the share grantor. Tapis will include the share grantor as part of authorization checks. 
     */
    async listFilesRaw(requestParameters: ListFilesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FileListingResponse>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling listFiles.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling listFiles.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.recurse !== undefined) {
            queryParameters['recurse'] = requestParameters.recurse;
        }

        if (requestParameters.impersonationId !== undefined) {
            queryParameters['impersonationId'] = requestParameters.impersonationId;
        }

        if (requestParameters.sharedCtx !== undefined) {
            queryParameters['sharedCtx'] = requestParameters.sharedCtx;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v3/files/ops/{systemId}/{path}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileListingResponseFromJSON(jsonValue));
    }

    /**
     * List files or objects on a Tapis system. Type for items will depend on system type. For example, for LINUX they will be posix files and for S3 they will be storage objects. For S3 the recurse flag is ignored and all objects with keys matching the path as a prefix are included.  For system types that support directory hierarchies the maximum recursion depth is 20.  Note that S3 buckets do not have a hierarchical structure. There are no directories. Everything is an object associated with a key.  Certain services may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization and resolving the *effectiveUserId* for the system.  Certain services may use the query parameter *sharedCtx* to indicate that the request is in a shared context. *sharedCtx* must be set to the share grantor. Tapis will include the share grantor as part of authorization checks. 
     */
    async listFiles(requestParameters: ListFilesRequest, initOverrides?: RequestInit): Promise<FileListingResponse> {
        const response = await this.listFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a directory on the system at the given path. Not supported for all system types. Currently supported for LINUX, IRODS and GLOBUS type systems.  Certain services may use the query parameter *sharedCtx* to indicate that the request is in a shared context. *sharedCtx* must be set to the share grantor. Tapis will include the share grantor as part of authorization checks.  If the path already exists as a directory, no error will be returned. 
     */
    async mkdirRaw(requestParameters: MkdirOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FileStringResponse>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling mkdir.');
        }

        const queryParameters: any = {};

        if (requestParameters.sharedCtx !== undefined) {
            queryParameters['sharedCtx'] = requestParameters.sharedCtx;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v3/files/ops/{systemId}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MkdirRequestToJSON(requestParameters.mkdirRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileStringResponseFromJSON(jsonValue));
    }

    /**
     * Create a directory on the system at the given path. Not supported for all system types. Currently supported for LINUX, IRODS and GLOBUS type systems.  Certain services may use the query parameter *sharedCtx* to indicate that the request is in a shared context. *sharedCtx* must be set to the share grantor. Tapis will include the share grantor as part of authorization checks.  If the path already exists as a directory, no error will be returned. 
     */
    async mkdir(requestParameters: MkdirOperationRequest, initOverrides?: RequestInit): Promise<FileStringResponse> {
        const response = await this.mkdirRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move or copy a file, directory or object on {systemID} at path {path}. Not all operations supported for all system types. 
     */
    async moveCopyRaw(requestParameters: MoveCopyOperationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FileStringResponse>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling moveCopy.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling moveCopy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v3/files/ops/{systemId}/{path}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MoveCopyRequestToJSON(requestParameters.moveCopyRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileStringResponseFromJSON(jsonValue));
    }

    /**
     * Move or copy a file, directory or object on {systemID} at path {path}. Not all operations supported for all system types. 
     */
    async moveCopy(requestParameters: MoveCopyOperationRequest, initOverrides?: RequestInit): Promise<FileStringResponse> {
        const response = await this.moveCopyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Run a native operation on a path. Operations are chmod, chown or chgrp. For a system of type LINUX. 
     */
    async runLinuxNativeOpRaw(requestParameters: RunLinuxNativeOpRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<NativeLinuxOpResultResponse>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling runLinuxNativeOp.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling runLinuxNativeOp.');
        }

        const queryParameters: any = {};

        if (requestParameters.recursive !== undefined) {
            queryParameters['recursive'] = requestParameters.recursive;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v3/files/utils/linux/{systemId}/{path}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NativeLinuxOpRequestToJSON(requestParameters.nativeLinuxOpRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NativeLinuxOpResultResponseFromJSON(jsonValue));
    }

    /**
     * Run a native operation on a path. Operations are chmod, chown or chgrp. For a system of type LINUX. 
     */
    async runLinuxNativeOp(requestParameters: RunLinuxNativeOpRequest, initOverrides?: RequestInit): Promise<NativeLinuxOpResultResponse> {
        const response = await this.runLinuxNativeOpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set file ACLs for files or directories for a system of type LINUX.  This can be used for a single file or directory, or can be recursive.  If recursion is used, it can be made to follow symlinks, or not follow symlinks.  The operations support adding or removing Acl Entries as well as removing all acls or all default acls 
     */
    async setFaclRaw(requestParameters: SetFaclRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<NativeLinuxSetFaclResponse>> {
        if (requestParameters.systemId === null || requestParameters.systemId === undefined) {
            throw new runtime.RequiredError('systemId','Required parameter requestParameters.systemId was null or undefined when calling setFacl.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling setFacl.');
        }

        if (requestParameters.nativeLinuxSetFaclRequest === null || requestParameters.nativeLinuxSetFaclRequest === undefined) {
            throw new runtime.RequiredError('nativeLinuxSetFaclRequest','Required parameter requestParameters.nativeLinuxSetFaclRequest was null or undefined when calling setFacl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v3/files/utils/linux/facl/{systemId}/{path}`.replace(`{${"systemId"}}`, encodeURIComponent(String(requestParameters.systemId))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NativeLinuxSetFaclRequestToJSON(requestParameters.nativeLinuxSetFaclRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NativeLinuxSetFaclResponseFromJSON(jsonValue));
    }

    /**
     * Set file ACLs for files or directories for a system of type LINUX.  This can be used for a single file or directory, or can be recursive.  If recursion is used, it can be made to follow symlinks, or not follow symlinks.  The operations support adding or removing Acl Entries as well as removing all acls or all default acls 
     */
    async setFacl(requestParameters: SetFaclRequest, initOverrides?: RequestInit): Promise<NativeLinuxSetFaclResponse> {
        const response = await this.setFaclRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
