/* tslint:disable */
/* eslint-disable */
/**
 * Tapis Applications API
 * The Tapis Applications API provides for management of Tapis applications including permissions.
 *
 * The version of the OpenAPI document: 1.4.2
 * Contact: cicsupport@tacc.utexas.edu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ListTypeEnum,
    ListTypeEnumFromJSON,
    ListTypeEnumToJSON,
    ReqPatchApp,
    ReqPatchAppFromJSON,
    ReqPatchAppToJSON,
    ReqPostApp,
    ReqPostAppFromJSON,
    ReqPostAppToJSON,
    ReqPutApp,
    ReqPutAppFromJSON,
    ReqPutAppToJSON,
    ReqSearchApps,
    ReqSearchAppsFromJSON,
    ReqSearchAppsToJSON,
    RespApp,
    RespAppFromJSON,
    RespAppToJSON,
    RespAppHistory,
    RespAppHistoryFromJSON,
    RespAppHistoryToJSON,
    RespApps,
    RespAppsFromJSON,
    RespAppsToJSON,
    RespBasic,
    RespBasicFromJSON,
    RespBasicToJSON,
    RespBoolean,
    RespBooleanFromJSON,
    RespBooleanToJSON,
    RespChangeCount,
    RespChangeCountFromJSON,
    RespChangeCountToJSON,
    RespResourceUrl,
    RespResourceUrlFromJSON,
    RespResourceUrlToJSON,
} from '../models';

export interface ChangeAppOwnerRequest {
    appId: string;
    userName: string;
}

export interface CreateAppVersionRequest {
    reqPostApp: ReqPostApp;
}

export interface DeleteAppRequest {
    appId: string;
}

export interface DisableAppRequest {
    appId: string;
}

export interface EnableAppRequest {
    appId: string;
}

export interface GetAppRequest {
    appId: string;
    appVersion: string;
    requireExecPerm?: boolean;
    impersonationId?: string;
    select?: string;
    resourceTenant?: string;
}

export interface GetAppLatestVersionRequest {
    appId: string;
    requireExecPerm?: boolean;
    select?: string;
    resourceTenant?: string;
}

export interface GetAppsRequest {
    search?: string;
    listType?: ListTypeEnum;
    limit?: number;
    orderBy?: string;
    skip?: number;
    startAfter?: string;
    computeTotal?: boolean;
    select?: string;
    showDeleted?: boolean;
}

export interface GetHistoryRequest {
    appId: string;
}

export interface IsEnabledRequest {
    appId: string;
}

export interface LockAppRequest {
    appId: string;
    appVersion: string;
}

export interface PatchAppRequest {
    appId: string;
    appVersion: string;
    reqPatchApp: ReqPatchApp;
}

export interface PutAppRequest {
    appId: string;
    appVersion: string;
    reqPutApp: ReqPutApp;
}

export interface SearchAppsQueryParametersRequest {
    listType?: ListTypeEnum;
    limit?: number;
    orderBy?: string;
    skip?: number;
    startAfter?: string;
    computeTotal?: boolean;
    select?: string;
}

export interface SearchAppsRequestBodyRequest {
    reqSearchApps: ReqSearchApps;
    listType?: ListTypeEnum;
    limit?: number;
    orderBy?: string;
    skip?: number;
    startAfter?: string;
    computeTotal?: boolean;
    select?: string;
}

export interface UndeleteAppRequest {
    appId: string;
}

export interface UnlockAppRequest {
    appId: string;
    appVersion: string;
}

/**
 * 
 */
export class ApplicationsApi extends runtime.BaseAPI {

    /**
     * Change owner of an application. Applies to all versions. 
     */
    async changeAppOwnerRaw(requestParameters: ChangeAppOwnerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling changeAppOwner.');
        }

        if (requestParameters.userName === null || requestParameters.userName === undefined) {
            throw new runtime.RequiredError('userName','Required parameter requestParameters.userName was null or undefined when calling changeAppOwner.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}/changeOwner/{userName}`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))).replace(`{${"userName"}}`, encodeURIComponent(String(requestParameters.userName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Change owner of an application. Applies to all versions. 
     */
    async changeAppOwner(requestParameters: ChangeAppOwnerRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.changeAppOwnerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an application using a request body. App id+version must be unique within tenant and can be composed of alphanumeric characters and the following special characters [-._~]. Id must begin with an alphanumeric character and can be no more than 80 characters in length.  Note that certain attributes (such as tenant) are allowed but ignored so that the JSON result returned by a GET may be modified and used when making a POST request to create an application. The attributes that are allowed but ignored are    - tenant   - uuid   - sharedAppCtx   - deleted   - created   - updated 
     */
    async createAppVersionRaw(requestParameters: CreateAppVersionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespResourceUrl>> {
        if (requestParameters.reqPostApp === null || requestParameters.reqPostApp === undefined) {
            throw new runtime.RequiredError('reqPostApp','Required parameter requestParameters.reqPostApp was null or undefined when calling createAppVersion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqPostAppToJSON(requestParameters.reqPostApp),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespResourceUrlFromJSON(jsonValue));
    }

    /**
     * Create an application using a request body. App id+version must be unique within tenant and can be composed of alphanumeric characters and the following special characters [-._~]. Id must begin with an alphanumeric character and can be no more than 80 characters in length.  Note that certain attributes (such as tenant) are allowed but ignored so that the JSON result returned by a GET may be modified and used when making a POST request to create an application. The attributes that are allowed but ignored are    - tenant   - uuid   - sharedAppCtx   - deleted   - created   - updated 
     */
    async createAppVersion(requestParameters: CreateAppVersionRequest, initOverrides?: RequestInit): Promise<RespResourceUrl> {
        const response = await this.createAppVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark an application as deleted. Application will not appear in queries unless explicitly requested. 
     */
    async deleteAppRaw(requestParameters: DeleteAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling deleteApp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}/delete`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Mark an application as deleted. Application will not appear in queries unless explicitly requested. 
     */
    async deleteApp(requestParameters: DeleteAppRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.deleteAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark an application unavailable for use. Applies to all versions. 
     */
    async disableAppRaw(requestParameters: DisableAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling disableApp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}/disable`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Mark an application unavailable for use. Applies to all versions. 
     */
    async disableApp(requestParameters: DisableAppRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.disableAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark an application available for use. Applies to all versions. 
     */
    async enableAppRaw(requestParameters: EnableAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling enableApp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}/enable`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Mark an application available for use. Applies to all versions. 
     */
    async enableApp(requestParameters: EnableAppRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.enableAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve information for an application given the application Id and version. In the result the attribute *sharedAppCtx* indicates if the application is available to the user because it has been shared with the user. The value of *sharedAppCtx* will be the grantor, the Tapis user who shared the application. Certain services may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization. 
     */
    async getAppRaw(requestParameters: GetAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespApp>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling getApp.');
        }

        if (requestParameters.appVersion === null || requestParameters.appVersion === undefined) {
            throw new runtime.RequiredError('appVersion','Required parameter requestParameters.appVersion was null or undefined when calling getApp.');
        }

        const queryParameters: any = {};

        if (requestParameters.requireExecPerm !== undefined) {
            queryParameters['requireExecPerm'] = requestParameters.requireExecPerm;
        }

        if (requestParameters.impersonationId !== undefined) {
            queryParameters['impersonationId'] = requestParameters.impersonationId;
        }

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        if (requestParameters.resourceTenant !== undefined) {
            queryParameters['resourceTenant'] = requestParameters.resourceTenant;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}/{appVersion}`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))).replace(`{${"appVersion"}}`, encodeURIComponent(String(requestParameters.appVersion))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAppFromJSON(jsonValue));
    }

    /**
     * Retrieve information for an application given the application Id and version. In the result the attribute *sharedAppCtx* indicates if the application is available to the user because it has been shared with the user. The value of *sharedAppCtx* will be the grantor, the Tapis user who shared the application. Certain services may use the query parameter *impersonationId* to be used in place of the requesting Tapis user. Tapis will use this user Id when performing authorization. 
     */
    async getApp(requestParameters: GetAppRequest, initOverrides?: RequestInit): Promise<RespApp> {
        const response = await this.getAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve latest version of an application. In the result the attribute *sharedAppCtx* indicates if the application is available to the user because it has been shared with the user. The value of *sharedAppCtx* will be the grantor, the Tapis user who shared the application. 
     */
    async getAppLatestVersionRaw(requestParameters: GetAppLatestVersionRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespApp>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling getAppLatestVersion.');
        }

        const queryParameters: any = {};

        if (requestParameters.requireExecPerm !== undefined) {
            queryParameters['requireExecPerm'] = requestParameters.requireExecPerm;
        }

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        if (requestParameters.resourceTenant !== undefined) {
            queryParameters['resourceTenant'] = requestParameters.resourceTenant;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAppFromJSON(jsonValue));
    }

    /**
     * Retrieve latest version of an application. In the result the attribute *sharedAppCtx* indicates if the application is available to the user because it has been shared with the user. The value of *sharedAppCtx* will be the grantor, the Tapis user who shared the application. 
     */
    async getAppLatestVersion(requestParameters: GetAppLatestVersionRequest, initOverrides?: RequestInit): Promise<RespApp> {
        const response = await this.getAppLatestVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve list of applications. Use *listType*, *search* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *SHARED_DIRECT* Include only items shared directly with requester. Exclude publicly shared items.   - *READ_PERM* Include only items for which requester was granter READ or MODIFY permission.   - *MINE* Include items owned or shared directly with requester. Exclude publicly shared items.   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. 
     */
    async getAppsRaw(requestParameters: GetAppsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespApps>> {
        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.listType !== undefined) {
            queryParameters['listType'] = requestParameters.listType;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.skip !== undefined) {
            queryParameters['skip'] = requestParameters.skip;
        }

        if (requestParameters.startAfter !== undefined) {
            queryParameters['startAfter'] = requestParameters.startAfter;
        }

        if (requestParameters.computeTotal !== undefined) {
            queryParameters['computeTotal'] = requestParameters.computeTotal;
        }

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        if (requestParameters.showDeleted !== undefined) {
            queryParameters['showDeleted'] = requestParameters.showDeleted;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAppsFromJSON(jsonValue));
    }

    /**
     * Retrieve list of applications. Use *listType*, *search* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *SHARED_DIRECT* Include only items shared directly with requester. Exclude publicly shared items.   - *READ_PERM* Include only items for which requester was granter READ or MODIFY permission.   - *MINE* Include items owned or shared directly with requester. Exclude publicly shared items.   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. 
     */
    async getApps(requestParameters: GetAppsRequest, initOverrides?: RequestInit): Promise<RespApps> {
        const response = await this.getAppsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve history of changes for a given appId. 
     */
    async getHistoryRaw(requestParameters: GetHistoryRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespAppHistory>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling getHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}/history`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAppHistoryFromJSON(jsonValue));
    }

    /**
     * Retrieve history of changes for a given appId. 
     */
    async getHistory(requestParameters: GetHistoryRequest, initOverrides?: RequestInit): Promise<RespAppHistory> {
        const response = await this.getHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check if an application is currently enabled, i.e. available for use. 
     */
    async isEnabledRaw(requestParameters: IsEnabledRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespBoolean>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling isEnabled.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}/isEnabled`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespBooleanFromJSON(jsonValue));
    }

    /**
     * Check if an application is currently enabled, i.e. available for use. 
     */
    async isEnabled(requestParameters: IsEnabledRequest, initOverrides?: RequestInit): Promise<RespBoolean> {
        const response = await this.isEnabledRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lock a version of an application to prevent updates via PUT or PATCH. Requester must be owner of the app or a tenant administrator. 
     */
    async lockAppRaw(requestParameters: LockAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling lockApp.');
        }

        if (requestParameters.appVersion === null || requestParameters.appVersion === undefined) {
            throw new runtime.RequiredError('appVersion','Required parameter requestParameters.appVersion was null or undefined when calling lockApp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}/{appVersion}/lock`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))).replace(`{${"appVersion"}}`, encodeURIComponent(String(requestParameters.appVersion))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Lock a version of an application to prevent updates via PUT or PATCH. Requester must be owner of the app or a tenant administrator. 
     */
    async lockApp(requestParameters: LockAppRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.lockAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update selected attributes of an existing version of an application. Request body may only contain updatable attributes. Application must exist.  Attributes that may not be updated via PATCH are    - id   - owner   - enabled   - locked  Note that the attributes owner, enabled and locked may be modified using other endpoints. 
     */
    async patchAppRaw(requestParameters: PatchAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespResourceUrl>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling patchApp.');
        }

        if (requestParameters.appVersion === null || requestParameters.appVersion === undefined) {
            throw new runtime.RequiredError('appVersion','Required parameter requestParameters.appVersion was null or undefined when calling patchApp.');
        }

        if (requestParameters.reqPatchApp === null || requestParameters.reqPatchApp === undefined) {
            throw new runtime.RequiredError('reqPatchApp','Required parameter requestParameters.reqPatchApp was null or undefined when calling patchApp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}/{appVersion}`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))).replace(`{${"appVersion"}}`, encodeURIComponent(String(requestParameters.appVersion))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ReqPatchAppToJSON(requestParameters.reqPatchApp),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespResourceUrlFromJSON(jsonValue));
    }

    /**
     * Update selected attributes of an existing version of an application. Request body may only contain updatable attributes. Application must exist.  Attributes that may not be updated via PATCH are    - id   - owner   - enabled   - locked  Note that the attributes owner, enabled and locked may be modified using other endpoints. 
     */
    async patchApp(requestParameters: PatchAppRequest, initOverrides?: RequestInit): Promise<RespResourceUrl> {
        const response = await this.patchAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update all updatable attributes of an application using a request body identical to POST. Application must exist.  Note that certain attributes (such as tenant) are allowed but ignored so that the JSON result returned by a GET may be modified and used when making a PUT request to update.  The attributes that are allowed but ignored for both PUT and POST are    - tenant   - uuid   - sharedAppCtx   - deleted   - created   - updated  In addition for a PUT operation the following non-updatable attributes are allowed but ignored    - id   - version   - owner   - enabled   - locked  Note that the attributes owner, enabled and locked may be modified using other endpoints. 
     */
    async putAppRaw(requestParameters: PutAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespResourceUrl>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling putApp.');
        }

        if (requestParameters.appVersion === null || requestParameters.appVersion === undefined) {
            throw new runtime.RequiredError('appVersion','Required parameter requestParameters.appVersion was null or undefined when calling putApp.');
        }

        if (requestParameters.reqPutApp === null || requestParameters.reqPutApp === undefined) {
            throw new runtime.RequiredError('reqPutApp','Required parameter requestParameters.reqPutApp was null or undefined when calling putApp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}/{appVersion}`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))).replace(`{${"appVersion"}}`, encodeURIComponent(String(requestParameters.appVersion))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ReqPutAppToJSON(requestParameters.reqPutApp),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespResourceUrlFromJSON(jsonValue));
    }

    /**
     * Update all updatable attributes of an application using a request body identical to POST. Application must exist.  Note that certain attributes (such as tenant) are allowed but ignored so that the JSON result returned by a GET may be modified and used when making a PUT request to update.  The attributes that are allowed but ignored for both PUT and POST are    - tenant   - uuid   - sharedAppCtx   - deleted   - created   - updated  In addition for a PUT operation the following non-updatable attributes are allowed but ignored    - id   - version   - owner   - enabled   - locked  Note that the attributes owner, enabled and locked may be modified using other endpoints. 
     */
    async putApp(requestParameters: PutAppRequest, initOverrides?: RequestInit): Promise<RespResourceUrl> {
        const response = await this.putAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve details for applications. Use query parameters to specify search conditions. For example ?owner.eq=jdoe&enabled.eq=false Use *listType* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *SHARED_DIRECT* Include only items shared directly with requester. Exclude publicly shared items.   - *READ_PERM* Include only items for which requester was granter READ or MODIFY permission.   - *MINE* Include items owned or shared directly with requester. Exclude publicly shared items.   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. 
     */
    async searchAppsQueryParametersRaw(requestParameters: SearchAppsQueryParametersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespApps>> {
        const queryParameters: any = {};

        if (requestParameters.listType !== undefined) {
            queryParameters['listType'] = requestParameters.listType;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.skip !== undefined) {
            queryParameters['skip'] = requestParameters.skip;
        }

        if (requestParameters.startAfter !== undefined) {
            queryParameters['startAfter'] = requestParameters.startAfter;
        }

        if (requestParameters.computeTotal !== undefined) {
            queryParameters['computeTotal'] = requestParameters.computeTotal;
        }

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAppsFromJSON(jsonValue));
    }

    /**
     * Retrieve details for applications. Use query parameters to specify search conditions. For example ?owner.eq=jdoe&enabled.eq=false Use *listType* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *SHARED_DIRECT* Include only items shared directly with requester. Exclude publicly shared items.   - *READ_PERM* Include only items for which requester was granter READ or MODIFY permission.   - *MINE* Include items owned or shared directly with requester. Exclude publicly shared items.   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. 
     */
    async searchAppsQueryParameters(requestParameters: SearchAppsQueryParametersRequest, initOverrides?: RequestInit): Promise<RespApps> {
        const response = await this.searchAppsQueryParametersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve details for applications. Use request body to specify SQL-like search conditions. Use *listType* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *SHARED_DIRECT* Include only items shared directly with requester. Exclude publicly shared items.   - *READ_PERM* Include only items for which requester was granter READ or MODIFY permission.   - *MINE* Include items owned or shared directly with requester. Exclude publicly shared items.   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. 
     */
    async searchAppsRequestBodyRaw(requestParameters: SearchAppsRequestBodyRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespApps>> {
        if (requestParameters.reqSearchApps === null || requestParameters.reqSearchApps === undefined) {
            throw new runtime.RequiredError('reqSearchApps','Required parameter requestParameters.reqSearchApps was null or undefined when calling searchAppsRequestBody.');
        }

        const queryParameters: any = {};

        if (requestParameters.listType !== undefined) {
            queryParameters['listType'] = requestParameters.listType;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['orderBy'] = requestParameters.orderBy;
        }

        if (requestParameters.skip !== undefined) {
            queryParameters['skip'] = requestParameters.skip;
        }

        if (requestParameters.startAfter !== undefined) {
            queryParameters['startAfter'] = requestParameters.startAfter;
        }

        if (requestParameters.computeTotal !== undefined) {
            queryParameters['computeTotal'] = requestParameters.computeTotal;
        }

        if (requestParameters.select !== undefined) {
            queryParameters['select'] = requestParameters.select;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReqSearchAppsToJSON(requestParameters.reqSearchApps),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespAppsFromJSON(jsonValue));
    }

    /**
     * Retrieve details for applications. Use request body to specify SQL-like search conditions. Use *listType* and *select* query parameters to limit results. Query parameter *listType* allows for filtering results based on authorization. Options for *listType* are    - *OWNED* Include only items owned by requester (Default)   - *SHARED_PUBLIC* Include only items shared publicly   - *SHARED_DIRECT* Include only items shared directly with requester. Exclude publicly shared items.   - *READ_PERM* Include only items for which requester was granter READ or MODIFY permission.   - *MINE* Include items owned or shared directly with requester. Exclude publicly shared items.   - *ALL* Include all items requester is authorized to view. Includes check for READ or MODIFY permission. 
     */
    async searchAppsRequestBody(requestParameters: SearchAppsRequestBodyRequest, initOverrides?: RequestInit): Promise<RespApps> {
        const response = await this.searchAppsRequestBodyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark an application as not deleted. Application will appear in queries. 
     */
    async undeleteAppRaw(requestParameters: UndeleteAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling undeleteApp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}/undelete`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Mark an application as not deleted. Application will appear in queries. 
     */
    async undeleteApp(requestParameters: UndeleteAppRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.undeleteAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unlock a version of an application to allow updates via PUT and PATCH. Requester must be owner of the app or a tenant administrator. 
     */
    async unlockAppRaw(requestParameters: UnlockAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RespChangeCount>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling unlockApp.');
        }

        if (requestParameters.appVersion === null || requestParameters.appVersion === undefined) {
            throw new runtime.RequiredError('appVersion','Required parameter requestParameters.appVersion was null or undefined when calling unlockApp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Tapis-Token"] = this.configuration.apiKey("X-Tapis-Token"); // TapisJWT authentication
        }

        const response = await this.request({
            path: `/v3/apps/{appId}/{appVersion}/unlock`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters.appId))).replace(`{${"appVersion"}}`, encodeURIComponent(String(requestParameters.appVersion))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RespChangeCountFromJSON(jsonValue));
    }

    /**
     * Unlock a version of an application to allow updates via PUT and PATCH. Requester must be owner of the app or a tenant administrator. 
     */
    async unlockApp(requestParameters: UnlockAppRequest, initOverrides?: RequestInit): Promise<RespChangeCount> {
        const response = await this.unlockAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
